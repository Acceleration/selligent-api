/**
 * Selligent Marketing Cloud API
 * Click the endpoint to see details. In the Parameters-section, we show an example of how the data you send along with the api-call looks like.
 *
 * The version of the OpenAPI document: v1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import localVarRequest = require('request');
import http = require('http');

/* tslint:disable:no-unused-locals */
import { CreateCustomEventFailedExampleResponse } from '../model/createCustomEventFailedExampleResponse';
import { CreateCustomEventFieldsFailedResponse } from '../model/createCustomEventFieldsFailedResponse';
import { CreateCustomEventFieldsRequestModel } from '../model/createCustomEventFieldsRequestModel';
import { CreateCustomEventFieldsSuccessResponse } from '../model/createCustomEventFieldsSuccessResponse';
import { CreateCustomEventRequestModel } from '../model/createCustomEventRequestModel';
import { CreateCustomEventSuccessExampleResponse } from '../model/createCustomEventSuccessExampleResponse';
import { CreateFieldsFailedResponse } from '../model/createFieldsFailedResponse';
import { CreateFieldsSuccessResponse } from '../model/createFieldsSuccessResponse';
import { CreateListFailedResponse } from '../model/createListFailedResponse';
import { CreateListFieldsRequestModel } from '../model/createListFieldsRequestModel';
import { CreateListRelationsFailedResponse } from '../model/createListRelationsFailedResponse';
import { CreateListRelationsRequestModel } from '../model/createListRelationsRequestModel';
import { CreateListRelationsSuccessResponse } from '../model/createListRelationsSuccessResponse';
import { CreateListRequestModel } from '../model/createListRequestModel';
import { CreateListSuccessResponse } from '../model/createListSuccessResponse';
import { CreateSegmentFailedResponse } from '../model/createSegmentFailedResponse';
import { CreateSegmentRequestModel } from '../model/createSegmentRequestModel';
import { CreateSegmentSuccessResponse } from '../model/createSegmentSuccessResponse';
import { CustomEvents } from '../model/customEvents';
import { DeleteCustomEventFailedResponse } from '../model/deleteCustomEventFailedResponse';
import { DeleteCustomEventFieldFailedResponse } from '../model/deleteCustomEventFieldFailedResponse';
import { DeleteCustomEventFieldSuccessResponse } from '../model/deleteCustomEventFieldSuccessResponse';
import { DeleteCustomEventSuccessResponse } from '../model/deleteCustomEventSuccessResponse';
import { DeleteListFailedResponse } from '../model/deleteListFailedResponse';
import { DeleteListFieldFailedResponse } from '../model/deleteListFieldFailedResponse';
import { DeleteListFieldSuccessResponse } from '../model/deleteListFieldSuccessResponse';
import { DeleteListRecordFailedResponse } from '../model/deleteListRecordFailedResponse';
import { DeleteListRecordSuccessResponse } from '../model/deleteListRecordSuccessResponse';
import { DeleteListRelationFailedResponse } from '../model/deleteListRelationFailedResponse';
import { DeleteListRelationSuccessResponse } from '../model/deleteListRelationSuccessResponse';
import { DeleteListSuccessResponse } from '../model/deleteListSuccessResponse';
import { DeleteSegmentFailedResponse } from '../model/deleteSegmentFailedResponse';
import { DeleteSegmentSuccessResponse } from '../model/deleteSegmentSuccessResponse';
import { Fields } from '../model/fields';
import { ListDetailsResponseModel } from '../model/listDetailsResponseModel';
import { ListRecordsCountSuccessResponse } from '../model/listRecordsCountSuccessResponse';
import { Lists } from '../model/lists';
import { RelationDetailsModel } from '../model/relationDetailsModel';
import { Relations } from '../model/relations';
import { RetrieveCustomEventSuccessResponse } from '../model/retrieveCustomEventSuccessResponse';
import { RetrieveEngagementListStructureExampleResponseModel } from '../model/retrieveEngagementListStructureExampleResponseModel';
import { RetrieveEngagementListStructureFailedExampleResponseModel } from '../model/retrieveEngagementListStructureFailedExampleResponseModel';
import { RetrieveInterestListStructureFailedExampleResponseModel } from '../model/retrieveInterestListStructureFailedExampleResponseModel';
import { RetrieveInterestListStructureSuccessExampleResponseModel } from '../model/retrieveInterestListStructureSuccessExampleResponseModel';
import { SegmentDetailsModel } from '../model/segmentDetailsModel';
import { Segments } from '../model/segments';
import { TriggerCustomEventAcceptedResponse } from '../model/triggerCustomEventAcceptedResponse';
import { TriggerCustomEventFailedResponse } from '../model/triggerCustomEventFailedResponse';
import { UpdateCustomEventFailedExampleResponse } from '../model/updateCustomEventFailedExampleResponse';
import { UpdateCustomEventFieldFailedResponse } from '../model/updateCustomEventFieldFailedResponse';
import { UpdateCustomEventFieldRequestModel } from '../model/updateCustomEventFieldRequestModel';
import { UpdateCustomEventFieldSuccessResponse } from '../model/updateCustomEventFieldSuccessResponse';
import { UpdateCustomEventRequestModel } from '../model/updateCustomEventRequestModel';
import { UpdateCustomEventSuccessExampleResponse } from '../model/updateCustomEventSuccessExampleResponse';
import { UpdateFieldFailedResponse } from '../model/updateFieldFailedResponse';
import { UpdateFieldSuccessResponse } from '../model/updateFieldSuccessResponse';
import { UpdateListFailedResponse } from '../model/updateListFailedResponse';
import { UpdateListFieldRequestModel } from '../model/updateListFieldRequestModel';
import { UpdateListRelationFailedResponse } from '../model/updateListRelationFailedResponse';
import { UpdateListRelationRequest } from '../model/updateListRelationRequest';
import { UpdateListRelationSuccessResponse } from '../model/updateListRelationSuccessResponse';
import { UpdateListRequestModel } from '../model/updateListRequestModel';
import { UpdateListSuccessResponse } from '../model/updateListSuccessResponse';

import { ObjectSerializer, Authentication, VoidAuth, Interceptor } from '../model/models';

import { HttpError, RequestFile } from './apis';

let defaultBasePath = 'http://localhost/Portal/Api';

// ===============================================
// This file is autogenerated - Please do not edit
// ===============================================

export enum ListApiApiKeys {
}

export class ListApi {
    protected _basePath = defaultBasePath;
    protected _defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    protected interceptors: Interceptor[] = [];

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    set defaultHeaders(defaultHeaders: any) {
        this._defaultHeaders = defaultHeaders;
    }

    get defaultHeaders() {
        return this._defaultHeaders;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
        this.authentications.default = auth;
    }

    public setApiKey(key: ListApiApiKeys, value: string) {
        (this.authentications as any)[ListApiApiKeys[key]].apiKey = value;
    }

    public addInterceptor(interceptor: Interceptor) {
        this.interceptors.push(interceptor);
    }

    /**
     * 
     * @summary Use this endpoint to create a new custom event.
     * @param apiName Parameter to specify API name of the list.
     * @param organization 
     * @param model The model object consists custom event details that are to used to create the custom event
     */
    public async listCreateCustomEvent (apiName: string, organization: string, model: CreateCustomEventRequestModel, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: CreateCustomEventSuccessExampleResponse;  }> {
        const localVarPath = this.basePath + '/organizations/{organization}/lists/{api_name}/customevents'
            .replace('{' + 'api_name' + '}', encodeURIComponent(String(apiName)))
            .replace('{' + 'organization' + '}', encodeURIComponent(String(organization)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json', 'text/json', 'result_code', 'message', 'errors', ];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'apiName' is not null or undefined
        if (apiName === null || apiName === undefined) {
            throw new Error('Required parameter apiName was null or undefined when calling listCreateCustomEvent.');
        }

        // verify required parameter 'organization' is not null or undefined
        if (organization === null || organization === undefined) {
            throw new Error('Required parameter organization was null or undefined when calling listCreateCustomEvent.');
        }

        // verify required parameter 'model' is not null or undefined
        if (model === null || model === undefined) {
            throw new Error('Required parameter model was null or undefined when calling listCreateCustomEvent.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(model, "CreateCustomEventRequestModel")
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: CreateCustomEventSuccessExampleResponse;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "CreateCustomEventSuccessExampleResponse");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * 
     * @summary Use this endpoint to create a custom event fields.
     * @param apiName Parameter to specify API name of the list.
     * @param customEventName Parameter to specify custom event name to be updated.
     * @param organization 
     * @param model The model object consists custom event details that are to used to create a custom event field
     */
    public async listCreateCustomEventFields (apiName: string, customEventName: string, organization: string, model: CreateCustomEventFieldsRequestModel, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: CreateCustomEventFieldsSuccessResponse;  }> {
        const localVarPath = this.basePath + '/organizations/{organization}/lists/{api_name}/customevents/{custom_event_name}/fields'
            .replace('{' + 'api_name' + '}', encodeURIComponent(String(apiName)))
            .replace('{' + 'custom_event_name' + '}', encodeURIComponent(String(customEventName)))
            .replace('{' + 'organization' + '}', encodeURIComponent(String(organization)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json', 'text/json', 'result_code', 'message', 'errors', ];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'apiName' is not null or undefined
        if (apiName === null || apiName === undefined) {
            throw new Error('Required parameter apiName was null or undefined when calling listCreateCustomEventFields.');
        }

        // verify required parameter 'customEventName' is not null or undefined
        if (customEventName === null || customEventName === undefined) {
            throw new Error('Required parameter customEventName was null or undefined when calling listCreateCustomEventFields.');
        }

        // verify required parameter 'organization' is not null or undefined
        if (organization === null || organization === undefined) {
            throw new Error('Required parameter organization was null or undefined when calling listCreateCustomEventFields.');
        }

        // verify required parameter 'model' is not null or undefined
        if (model === null || model === undefined) {
            throw new Error('Required parameter model was null or undefined when calling listCreateCustomEventFields.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(model, "CreateCustomEventFieldsRequestModel")
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: CreateCustomEventFieldsSuccessResponse;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "CreateCustomEventFieldsSuccessResponse");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * 
     * @summary Use this endpoint to create a new list in the given organization.
     * @param organization 
     * @param model This CreateListRequestModel model parameter having information about list as name, api_name, listType, description and tags to be created .
     */
    public async listCreateList (organization: string, model: CreateListRequestModel, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: CreateListSuccessResponse;  }> {
        const localVarPath = this.basePath + '/organizations/{organization}/lists'
            .replace('{' + 'organization' + '}', encodeURIComponent(String(organization)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json', 'text/json', 'result_code', 'message', 'errors', ];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'organization' is not null or undefined
        if (organization === null || organization === undefined) {
            throw new Error('Required parameter organization was null or undefined when calling listCreateList.');
        }

        // verify required parameter 'model' is not null or undefined
        if (model === null || model === undefined) {
            throw new Error('Required parameter model was null or undefined when calling listCreateList.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(model, "CreateListRequestModel")
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: CreateListSuccessResponse;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "CreateListSuccessResponse");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * 
     * @summary Use this endpoint to create list fields.
     * @param apiName The api name of of the list
     * @param organization 
     * @param model The model containing the data that should be sent
     */
    public async listCreateListFields (apiName: string, organization: string, model: CreateListFieldsRequestModel, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: CreateFieldsSuccessResponse;  }> {
        const localVarPath = this.basePath + '/organizations/{organization}/lists/{api_name}/fields'
            .replace('{' + 'api_name' + '}', encodeURIComponent(String(apiName)))
            .replace('{' + 'organization' + '}', encodeURIComponent(String(organization)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json', 'text/json', 'result_code', 'message', 'errors', ];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'apiName' is not null or undefined
        if (apiName === null || apiName === undefined) {
            throw new Error('Required parameter apiName was null or undefined when calling listCreateListFields.');
        }

        // verify required parameter 'organization' is not null or undefined
        if (organization === null || organization === undefined) {
            throw new Error('Required parameter organization was null or undefined when calling listCreateListFields.');
        }

        // verify required parameter 'model' is not null or undefined
        if (model === null || model === undefined) {
            throw new Error('Required parameter model was null or undefined when calling listCreateListFields.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(model, "CreateListFieldsRequestModel")
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: CreateFieldsSuccessResponse;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "CreateFieldsSuccessResponse");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * 
     * @summary Use this endpoint to create relations between 2 lists.
     * @param apiName 
     * @param organization 
     * @param model 
     */
    public async listCreateListRelations (apiName: string, organization: string, model: CreateListRelationsRequestModel, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: CreateListRelationsSuccessResponse;  }> {
        const localVarPath = this.basePath + '/organizations/{organization}/lists/{api_name}/relations'
            .replace('{' + 'api_name' + '}', encodeURIComponent(String(apiName)))
            .replace('{' + 'organization' + '}', encodeURIComponent(String(organization)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json', 'text/json', 'result_code', 'errors', 'message', ];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'apiName' is not null or undefined
        if (apiName === null || apiName === undefined) {
            throw new Error('Required parameter apiName was null or undefined when calling listCreateListRelations.');
        }

        // verify required parameter 'organization' is not null or undefined
        if (organization === null || organization === undefined) {
            throw new Error('Required parameter organization was null or undefined when calling listCreateListRelations.');
        }

        // verify required parameter 'model' is not null or undefined
        if (model === null || model === undefined) {
            throw new Error('Required parameter model was null or undefined when calling listCreateListRelations.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(model, "CreateListRelationsRequestModel")
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: CreateListRelationsSuccessResponse;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "CreateListRelationsSuccessResponse");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * 
     * @summary Use this endpoint to create static segment based on list API name and provided segment info parameters.
     * @param apiName 
     * @param organization 
     * @param model 
     */
    public async listCreateStaticSegment (apiName: string, organization: string, model: CreateSegmentRequestModel, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: CreateSegmentSuccessResponse;  }> {
        const localVarPath = this.basePath + '/organizations/{organization}/lists/{api_name}/segments/static'
            .replace('{' + 'api_name' + '}', encodeURIComponent(String(apiName)))
            .replace('{' + 'organization' + '}', encodeURIComponent(String(organization)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json', 'text/json', 'result_code', 'message', 'errors', ];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'apiName' is not null or undefined
        if (apiName === null || apiName === undefined) {
            throw new Error('Required parameter apiName was null or undefined when calling listCreateStaticSegment.');
        }

        // verify required parameter 'organization' is not null or undefined
        if (organization === null || organization === undefined) {
            throw new Error('Required parameter organization was null or undefined when calling listCreateStaticSegment.');
        }

        // verify required parameter 'model' is not null or undefined
        if (model === null || model === undefined) {
            throw new Error('Required parameter model was null or undefined when calling listCreateStaticSegment.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(model, "CreateSegmentRequestModel")
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: CreateSegmentSuccessResponse;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "CreateSegmentSuccessResponse");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * 
     * @summary Use this endpoint to delete a list by its API name in the given organization.
     * @param apiName Parameter to specify API name of the list.
     * @param organization 
     * @param dropTable Optional Parameter to specify if the associated table is to be deleted.
     */
    public async listDelete (apiName: string, organization: string, dropTable?: boolean, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: DeleteListSuccessResponse;  }> {
        const localVarPath = this.basePath + '/organizations/{organization}/lists/{api_name}'
            .replace('{' + 'api_name' + '}', encodeURIComponent(String(apiName)))
            .replace('{' + 'organization' + '}', encodeURIComponent(String(organization)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json', 'text/json', 'result_code', 'message', 'errors', ];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'apiName' is not null or undefined
        if (apiName === null || apiName === undefined) {
            throw new Error('Required parameter apiName was null or undefined when calling listDelete.');
        }

        // verify required parameter 'organization' is not null or undefined
        if (organization === null || organization === undefined) {
            throw new Error('Required parameter organization was null or undefined when calling listDelete.');
        }

        if (dropTable !== undefined) {
            localVarQueryParameters['dropTable'] = ObjectSerializer.serialize(dropTable, "boolean");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: DeleteListSuccessResponse;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "DeleteListSuccessResponse");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * 
     * @summary Use this endpoint to delete a custom event by its name in the given organization.
     * @param apiName Parameter to specify API name of the list.
     * @param customEventName Parameter to specify name of the custom event.
     * @param organization 
     * @param dropTable Optional Parameter to specify if the associated table is to be deleted.
     */
    public async listDeleteCustomEvent (apiName: string, customEventName: string, organization: string, dropTable?: boolean, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: DeleteCustomEventSuccessResponse;  }> {
        const localVarPath = this.basePath + '/organizations/{organization}/lists/{api_name}/customevents/{custom_event_name}'
            .replace('{' + 'api_name' + '}', encodeURIComponent(String(apiName)))
            .replace('{' + 'custom_event_name' + '}', encodeURIComponent(String(customEventName)))
            .replace('{' + 'organization' + '}', encodeURIComponent(String(organization)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json', 'text/json', 'result_code', 'message', 'errors', ];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'apiName' is not null or undefined
        if (apiName === null || apiName === undefined) {
            throw new Error('Required parameter apiName was null or undefined when calling listDeleteCustomEvent.');
        }

        // verify required parameter 'customEventName' is not null or undefined
        if (customEventName === null || customEventName === undefined) {
            throw new Error('Required parameter customEventName was null or undefined when calling listDeleteCustomEvent.');
        }

        // verify required parameter 'organization' is not null or undefined
        if (organization === null || organization === undefined) {
            throw new Error('Required parameter organization was null or undefined when calling listDeleteCustomEvent.');
        }

        if (dropTable !== undefined) {
            localVarQueryParameters['dropTable'] = ObjectSerializer.serialize(dropTable, "boolean");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: DeleteCustomEventSuccessResponse;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "DeleteCustomEventSuccessResponse");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * 
     * @summary Use this endpoint to delete a custom event field based on list\'s API name, custom event name and name of the field
     * @param apiName Parameter to specify API name of the list.
     * @param customEventName Parameter to specify name of the custom event.
     * @param fieldName Parameter to specify name of the custom event field.
     * @param organization 
     */
    public async listDeleteCustomEventField (apiName: string, customEventName: string, fieldName: string, organization: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: DeleteCustomEventFieldSuccessResponse;  }> {
        const localVarPath = this.basePath + '/organizations/{organization}/lists/{api_name}/customevents/{custom_event_name}/fields/{field_name}'
            .replace('{' + 'api_name' + '}', encodeURIComponent(String(apiName)))
            .replace('{' + 'custom_event_name' + '}', encodeURIComponent(String(customEventName)))
            .replace('{' + 'field_name' + '}', encodeURIComponent(String(fieldName)))
            .replace('{' + 'organization' + '}', encodeURIComponent(String(organization)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json', 'text/json', 'result_code', 'message', 'errors', ];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'apiName' is not null or undefined
        if (apiName === null || apiName === undefined) {
            throw new Error('Required parameter apiName was null or undefined when calling listDeleteCustomEventField.');
        }

        // verify required parameter 'customEventName' is not null or undefined
        if (customEventName === null || customEventName === undefined) {
            throw new Error('Required parameter customEventName was null or undefined when calling listDeleteCustomEventField.');
        }

        // verify required parameter 'fieldName' is not null or undefined
        if (fieldName === null || fieldName === undefined) {
            throw new Error('Required parameter fieldName was null or undefined when calling listDeleteCustomEventField.');
        }

        // verify required parameter 'organization' is not null or undefined
        if (organization === null || organization === undefined) {
            throw new Error('Required parameter organization was null or undefined when calling listDeleteCustomEventField.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: DeleteCustomEventFieldSuccessResponse;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "DeleteCustomEventFieldSuccessResponse");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * 
     * @summary Use this endpoint to delete a list field based on list\'s API name and name of the field
     * @param apiName Parameter to specify API name of list.
     * @param name Parameter to specify name of the field
     * @param organization 
     */
    public async listDeleteListField (apiName: string, name: string, organization: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: DeleteListFieldSuccessResponse;  }> {
        const localVarPath = this.basePath + '/organizations/{organization}/lists/{api_name}/fields/{name}'
            .replace('{' + 'api_name' + '}', encodeURIComponent(String(apiName)))
            .replace('{' + 'name' + '}', encodeURIComponent(String(name)))
            .replace('{' + 'organization' + '}', encodeURIComponent(String(organization)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json', 'text/json', 'result_code', 'message', 'errors', ];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'apiName' is not null or undefined
        if (apiName === null || apiName === undefined) {
            throw new Error('Required parameter apiName was null or undefined when calling listDeleteListField.');
        }

        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling listDeleteListField.');
        }

        // verify required parameter 'organization' is not null or undefined
        if (organization === null || organization === undefined) {
            throw new Error('Required parameter organization was null or undefined when calling listDeleteListField.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: DeleteListFieldSuccessResponse;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "DeleteListFieldSuccessResponse");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * 
     * @summary Use this endpoint to delete single record by its record Id.
     * @param apiName Parameter to specify API name of the list.
     * @param recordId Required Parameter to specify if the associated record is to be deleted.
     * @param organization 
     */
    public async listDeleteListRecord (apiName: string, recordId: number, organization: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: DeleteListRecordSuccessResponse;  }> {
        const localVarPath = this.basePath + '/organizations/{organization}/lists/{api_name}/records/{record_id}'
            .replace('{' + 'api_name' + '}', encodeURIComponent(String(apiName)))
            .replace('{' + 'record_id' + '}', encodeURIComponent(String(recordId)))
            .replace('{' + 'organization' + '}', encodeURIComponent(String(organization)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json', 'text/json', 'result_code', 'errors', 'message', ];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'apiName' is not null or undefined
        if (apiName === null || apiName === undefined) {
            throw new Error('Required parameter apiName was null or undefined when calling listDeleteListRecord.');
        }

        // verify required parameter 'recordId' is not null or undefined
        if (recordId === null || recordId === undefined) {
            throw new Error('Required parameter recordId was null or undefined when calling listDeleteListRecord.');
        }

        // verify required parameter 'organization' is not null or undefined
        if (organization === null || organization === undefined) {
            throw new Error('Required parameter organization was null or undefined when calling listDeleteListRecord.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: DeleteListRecordSuccessResponse;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "DeleteListRecordSuccessResponse");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * 
     * @summary Use this endpoint to delete a relation between this list and another.
     * @param apiName 
     * @param scope 
     * @param organization 
     */
    public async listDeleteRelation (apiName: string, scope: string, organization: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: DeleteListRelationSuccessResponse;  }> {
        const localVarPath = this.basePath + '/organizations/{organization}/lists/{api_name}/relations/{scope}'
            .replace('{' + 'api_name' + '}', encodeURIComponent(String(apiName)))
            .replace('{' + 'scope' + '}', encodeURIComponent(String(scope)))
            .replace('{' + 'organization' + '}', encodeURIComponent(String(organization)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json', 'text/json', 'result_code', 'message', 'errors', ];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'apiName' is not null or undefined
        if (apiName === null || apiName === undefined) {
            throw new Error('Required parameter apiName was null or undefined when calling listDeleteRelation.');
        }

        // verify required parameter 'scope' is not null or undefined
        if (scope === null || scope === undefined) {
            throw new Error('Required parameter scope was null or undefined when calling listDeleteRelation.');
        }

        // verify required parameter 'organization' is not null or undefined
        if (organization === null || organization === undefined) {
            throw new Error('Required parameter organization was null or undefined when calling listDeleteRelation.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: DeleteListRelationSuccessResponse;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "DeleteListRelationSuccessResponse");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * 
     * @summary Use this endpoint to delete a segment by its API name in the given organization.
     * @param apiName Parameter to specify API name of the list.
     * @param segmentApiName Parameter to specify API name of the segment.
     * @param organization 
     */
    public async listDeleteSegment (apiName: string, segmentApiName: string, organization: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: DeleteSegmentSuccessResponse;  }> {
        const localVarPath = this.basePath + '/organizations/{organization}/lists/{api_name}/segments/{segment_api_name}'
            .replace('{' + 'api_name' + '}', encodeURIComponent(String(apiName)))
            .replace('{' + 'segment_api_name' + '}', encodeURIComponent(String(segmentApiName)))
            .replace('{' + 'organization' + '}', encodeURIComponent(String(organization)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json', 'text/json', 'result_code', 'message', 'errors', ];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'apiName' is not null or undefined
        if (apiName === null || apiName === undefined) {
            throw new Error('Required parameter apiName was null or undefined when calling listDeleteSegment.');
        }

        // verify required parameter 'segmentApiName' is not null or undefined
        if (segmentApiName === null || segmentApiName === undefined) {
            throw new Error('Required parameter segmentApiName was null or undefined when calling listDeleteSegment.');
        }

        // verify required parameter 'organization' is not null or undefined
        if (organization === null || organization === undefined) {
            throw new Error('Required parameter organization was null or undefined when calling listDeleteSegment.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: DeleteSegmentSuccessResponse;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "DeleteSegmentSuccessResponse");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * 
     * @summary This endpoint will return the engagement list structure for specified channel type for an user list.
     * @param apiName Parameter to specify API name of the user list.
     * @param channel Parameter to specify channel type of taglist engagement for the user list.
     * @param organization 
     */
    public async listGetEngagementListStructure (apiName: string, channel: 'Email' | 'Sms' | 'Mobile' | 'Web', organization: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: RetrieveEngagementListStructureExampleResponseModel;  }> {
        const localVarPath = this.basePath + '/organizations/{organization}/lists/{api_name}/engagement/{channel}/structure'
            .replace('{' + 'api_name' + '}', encodeURIComponent(String(apiName)))
            .replace('{' + 'channel' + '}', encodeURIComponent(String(channel)))
            .replace('{' + 'organization' + '}', encodeURIComponent(String(organization)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json', 'text/json', 'fields', 'errors', 'result_code', ];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'apiName' is not null or undefined
        if (apiName === null || apiName === undefined) {
            throw new Error('Required parameter apiName was null or undefined when calling listGetEngagementListStructure.');
        }

        // verify required parameter 'channel' is not null or undefined
        if (channel === null || channel === undefined) {
            throw new Error('Required parameter channel was null or undefined when calling listGetEngagementListStructure.');
        }

        // verify required parameter 'organization' is not null or undefined
        if (organization === null || organization === undefined) {
            throw new Error('Required parameter organization was null or undefined when calling listGetEngagementListStructure.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: RetrieveEngagementListStructureExampleResponseModel;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "RetrieveEngagementListStructureExampleResponseModel");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * 
     * @summary This endpoint will return the interest list structure for specified channel type for an user list.
     * @param apiName Parameter to specify API name of the user list.
     * @param channel Parameter to specify channel type of taglist interest for the user list.
     * @param organization 
     */
    public async listGetInterestListStructure (apiName: string, channel: 'Email' | 'Sms' | 'Mobile' | 'Web', organization: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: RetrieveInterestListStructureSuccessExampleResponseModel;  }> {
        const localVarPath = this.basePath + '/organizations/{organization}/lists/{api_name}/interest/{channel}/structure'
            .replace('{' + 'api_name' + '}', encodeURIComponent(String(apiName)))
            .replace('{' + 'channel' + '}', encodeURIComponent(String(channel)))
            .replace('{' + 'organization' + '}', encodeURIComponent(String(organization)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json', 'text/json', 'fields', 'errors', 'result_code', ];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'apiName' is not null or undefined
        if (apiName === null || apiName === undefined) {
            throw new Error('Required parameter apiName was null or undefined when calling listGetInterestListStructure.');
        }

        // verify required parameter 'channel' is not null or undefined
        if (channel === null || channel === undefined) {
            throw new Error('Required parameter channel was null or undefined when calling listGetInterestListStructure.');
        }

        // verify required parameter 'organization' is not null or undefined
        if (organization === null || organization === undefined) {
            throw new Error('Required parameter organization was null or undefined when calling listGetInterestListStructure.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: RetrieveInterestListStructureSuccessExampleResponseModel;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "RetrieveInterestListStructureSuccessExampleResponseModel");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * 
     * @summary Use this endpoint to get a list of details for the list with the given by API name.
     * @param apiName Parameter represents API name of the list.
     * @param organization 
     */
    public async listGetList (apiName: string, organization: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: ListDetailsResponseModel;  }> {
        const localVarPath = this.basePath + '/organizations/{organization}/lists/{api_name}'
            .replace('{' + 'api_name' + '}', encodeURIComponent(String(apiName)))
            .replace('{' + 'organization' + '}', encodeURIComponent(String(organization)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json', 'text/json', 'api_name', 'name', 'type', 'description', 'tags', 'email_quality_configuration', 'enforce_segment_selection', 'taglist_api_name', 'organizations', 'not_accessible_organizations_count'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'apiName' is not null or undefined
        if (apiName === null || apiName === undefined) {
            throw new Error('Required parameter apiName was null or undefined when calling listGetList.');
        }

        // verify required parameter 'organization' is not null or undefined
        if (organization === null || organization === undefined) {
            throw new Error('Required parameter organization was null or undefined when calling listGetList.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: ListDetailsResponseModel;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "ListDetailsResponseModel");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * 
     * @summary Use this endpoint to get list fields based on API name of list.
     * @param apiName Parameter for API name associated with a list
     * @param organization 
     */
    public async listGetListFields (apiName: string, organization: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: Fields;  }> {
        const localVarPath = this.basePath + '/organizations/{organization}/lists/{api_name}/fields'
            .replace('{' + 'api_name' + '}', encodeURIComponent(String(apiName)))
            .replace('{' + 'organization' + '}', encodeURIComponent(String(organization)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json', 'text/json', 'fields'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'apiName' is not null or undefined
        if (apiName === null || apiName === undefined) {
            throw new Error('Required parameter apiName was null or undefined when calling listGetListFields.');
        }

        // verify required parameter 'organization' is not null or undefined
        if (organization === null || organization === undefined) {
            throw new Error('Required parameter organization was null or undefined when calling listGetListFields.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: Fields;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "Fields");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * 
     * @summary Use this endpoint to get records count by API name of list.
     * @param apiName Parameter to specify API name of the list.
     * @param organization 
     */
    public async listGetListRecordsCount (apiName: string, organization: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: ListRecordsCountSuccessResponse;  }> {
        const localVarPath = this.basePath + '/organizations/{organization}/lists/{api_name}/records'
            .replace('{' + 'api_name' + '}', encodeURIComponent(String(apiName)))
            .replace('{' + 'organization' + '}', encodeURIComponent(String(organization)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json', 'text/json', 'count'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'apiName' is not null or undefined
        if (apiName === null || apiName === undefined) {
            throw new Error('Required parameter apiName was null or undefined when calling listGetListRecordsCount.');
        }

        // verify required parameter 'organization' is not null or undefined
        if (organization === null || organization === undefined) {
            throw new Error('Required parameter organization was null or undefined when calling listGetListRecordsCount.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: ListRecordsCountSuccessResponse;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "ListRecordsCountSuccessResponse");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * 
     * @summary Use this endpoint to get segment details based on list API name and segment API name.
     * @param apiName Parameter to specify API name of the list
     * @param segmentApiName Parameter to specify API name of the segment
     * @param organization 
     */
    public async listGetListSegment (apiName: string, segmentApiName: string, organization: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: SegmentDetailsModel;  }> {
        const localVarPath = this.basePath + '/organizations/{organization}/lists/{api_name}/segments/{segment_api_name}'
            .replace('{' + 'api_name' + '}', encodeURIComponent(String(apiName)))
            .replace('{' + 'segment_api_name' + '}', encodeURIComponent(String(segmentApiName)))
            .replace('{' + 'organization' + '}', encodeURIComponent(String(organization)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json', 'text/json', 'type', 'api_name', 'name', 'description'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'apiName' is not null or undefined
        if (apiName === null || apiName === undefined) {
            throw new Error('Required parameter apiName was null or undefined when calling listGetListSegment.');
        }

        // verify required parameter 'segmentApiName' is not null or undefined
        if (segmentApiName === null || segmentApiName === undefined) {
            throw new Error('Required parameter segmentApiName was null or undefined when calling listGetListSegment.');
        }

        // verify required parameter 'organization' is not null or undefined
        if (organization === null || organization === undefined) {
            throw new Error('Required parameter organization was null or undefined when calling listGetListSegment.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: SegmentDetailsModel;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "SegmentDetailsModel");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * 
     * @summary Use this endpoint to get an overview of the segments defined on the given list.
     * @param apiName api name of the List for which segments are requested.
     * @param organization 
     * @param filter Optional parameter to filter segment by type.
     * @param search Optional parameter to search a segment with a specific name, description or tags.
     * @param skip Optional parameter to specify index to start picking segment items from.
     * @param take Optional parameter to specify count for the number of segment items to be taken.
     */
    public async listGetListSegments (apiName: string, organization: string, filter?: string, search?: string, skip?: number, take?: number, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: Segments;  }> {
        const localVarPath = this.basePath + '/organizations/{organization}/lists/{api_name}/segments'
            .replace('{' + 'api_name' + '}', encodeURIComponent(String(apiName)))
            .replace('{' + 'organization' + '}', encodeURIComponent(String(organization)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json', 'text/json', 'segments', 'segment_count'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'apiName' is not null or undefined
        if (apiName === null || apiName === undefined) {
            throw new Error('Required parameter apiName was null or undefined when calling listGetListSegments.');
        }

        // verify required parameter 'organization' is not null or undefined
        if (organization === null || organization === undefined) {
            throw new Error('Required parameter organization was null or undefined when calling listGetListSegments.');
        }

        if (filter !== undefined) {
            localVarQueryParameters['filter'] = ObjectSerializer.serialize(filter, "string");
        }

        if (search !== undefined) {
            localVarQueryParameters['search'] = ObjectSerializer.serialize(search, "string");
        }

        if (skip !== undefined) {
            localVarQueryParameters['skip'] = ObjectSerializer.serialize(skip, "number");
        }

        if (take !== undefined) {
            localVarQueryParameters['take'] = ObjectSerializer.serialize(take, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: Segments;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "Segments");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * 
     * @summary Use this endpoint to retrieve an overview of all of the lists set up in the given organization.
     * @param organization 
     * @param filter Optional parameter to filter list by type. (Userlist, Datalist, Dataselectionlist or Optionlist)
     * @param search Optional parameter to search a list with a specific name, description or tags.
     * @param skip Optional parameter to specify index to start picking list items from.
     * @param take Optional parameter to specify count for the number of list items to be taken.
     */
    public async listGetLists (organization: string, filter?: string, search?: string, skip?: number, take?: number, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: Lists;  }> {
        const localVarPath = this.basePath + '/organizations/{organization}/lists'
            .replace('{' + 'organization' + '}', encodeURIComponent(String(organization)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json', 'text/json', 'list'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'organization' is not null or undefined
        if (organization === null || organization === undefined) {
            throw new Error('Required parameter organization was null or undefined when calling listGetLists.');
        }

        if (filter !== undefined) {
            localVarQueryParameters['filter'] = ObjectSerializer.serialize(filter, "string");
        }

        if (search !== undefined) {
            localVarQueryParameters['search'] = ObjectSerializer.serialize(search, "string");
        }

        if (skip !== undefined) {
            localVarQueryParameters['skip'] = ObjectSerializer.serialize(skip, "number");
        }

        if (take !== undefined) {
            localVarQueryParameters['take'] = ObjectSerializer.serialize(take, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: Lists;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "Lists");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * 
     * @summary Use this endpoint to get relation details based on API name of the list and name of the relation.
     * @param apiName Parameter to specify API name of the list
     * @param scope Parameter to specify scope name of the relation
     * @param organization 
     */
    public async listGetRelationDetails (apiName: string, scope: string, organization: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: RelationDetailsModel;  }> {
        const localVarPath = this.basePath + '/organizations/{organization}/lists/{api_name}/relations/{scope}'
            .replace('{' + 'api_name' + '}', encodeURIComponent(String(apiName)))
            .replace('{' + 'scope' + '}', encodeURIComponent(String(scope)))
            .replace('{' + 'organization' + '}', encodeURIComponent(String(organization)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json', 'text/json', 'scope_name', 'relation_type', 'master_list_api_name', 'master_list_field_name', 'slave_list_api_name', 'slave_list_field_name', 'constraints'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'apiName' is not null or undefined
        if (apiName === null || apiName === undefined) {
            throw new Error('Required parameter apiName was null or undefined when calling listGetRelationDetails.');
        }

        // verify required parameter 'scope' is not null or undefined
        if (scope === null || scope === undefined) {
            throw new Error('Required parameter scope was null or undefined when calling listGetRelationDetails.');
        }

        // verify required parameter 'organization' is not null or undefined
        if (organization === null || organization === undefined) {
            throw new Error('Required parameter organization was null or undefined when calling listGetRelationDetails.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: RelationDetailsModel;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "RelationDetailsModel");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * 
     * @summary Use this endpoint to get all relations associated with a list.
     * @param apiName Parameter for API name associated with a list
     * @param organization 
     * @param filter Optional parameter to filter relations by type. (OneToOne, OneToMany or ManyToOne)
     */
    public async listGetRelations (apiName: string, organization: string, filter?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: Relations;  }> {
        const localVarPath = this.basePath + '/organizations/{organization}/lists/{api_name}/relations'
            .replace('{' + 'api_name' + '}', encodeURIComponent(String(apiName)))
            .replace('{' + 'organization' + '}', encodeURIComponent(String(organization)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json', 'text/json', 'relations'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'apiName' is not null or undefined
        if (apiName === null || apiName === undefined) {
            throw new Error('Required parameter apiName was null or undefined when calling listGetRelations.');
        }

        // verify required parameter 'organization' is not null or undefined
        if (organization === null || organization === undefined) {
            throw new Error('Required parameter organization was null or undefined when calling listGetRelations.');
        }

        if (filter !== undefined) {
            localVarQueryParameters['filter'] = ObjectSerializer.serialize(filter, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: Relations;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "Relations");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * 
     * @summary Use this endpoint to get custom event details based on list API name and custom event name.
     * @param apiName Parameter to specify API name of the list.
     * @param customEventName Parameter to specify name of the custom event.
     * @param organization 
     */
    public async listRetrieveCustomEvent (apiName: string, customEventName: string, organization: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: RetrieveCustomEventSuccessResponse;  }> {
        const localVarPath = this.basePath + '/organizations/{organization}/lists/{api_name}/customevents/{custom_event_name}'
            .replace('{' + 'api_name' + '}', encodeURIComponent(String(apiName)))
            .replace('{' + 'custom_event_name' + '}', encodeURIComponent(String(customEventName)))
            .replace('{' + 'organization' + '}', encodeURIComponent(String(organization)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json', 'text/json', 'custom_event'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'apiName' is not null or undefined
        if (apiName === null || apiName === undefined) {
            throw new Error('Required parameter apiName was null or undefined when calling listRetrieveCustomEvent.');
        }

        // verify required parameter 'customEventName' is not null or undefined
        if (customEventName === null || customEventName === undefined) {
            throw new Error('Required parameter customEventName was null or undefined when calling listRetrieveCustomEvent.');
        }

        // verify required parameter 'organization' is not null or undefined
        if (organization === null || organization === undefined) {
            throw new Error('Required parameter organization was null or undefined when calling listRetrieveCustomEvent.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: RetrieveCustomEventSuccessResponse;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "RetrieveCustomEventSuccessResponse");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * 
     * @summary Use this endpoint to get custom event fields based on list API name and custom event name.
     * @param apiName Parameter to specify API name of the list.
     * @param customEventName Parameter to specify name of the custom event.
     * @param organization 
     */
    public async listRetrieveCustomEventFields (apiName: string, customEventName: string, organization: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: Fields;  }> {
        const localVarPath = this.basePath + '/organizations/{organization}/lists/{api_name}/customevents/{custom_event_name}/fields'
            .replace('{' + 'api_name' + '}', encodeURIComponent(String(apiName)))
            .replace('{' + 'custom_event_name' + '}', encodeURIComponent(String(customEventName)))
            .replace('{' + 'organization' + '}', encodeURIComponent(String(organization)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json', 'text/json', 'fields'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'apiName' is not null or undefined
        if (apiName === null || apiName === undefined) {
            throw new Error('Required parameter apiName was null or undefined when calling listRetrieveCustomEventFields.');
        }

        // verify required parameter 'customEventName' is not null or undefined
        if (customEventName === null || customEventName === undefined) {
            throw new Error('Required parameter customEventName was null or undefined when calling listRetrieveCustomEventFields.');
        }

        // verify required parameter 'organization' is not null or undefined
        if (organization === null || organization === undefined) {
            throw new Error('Required parameter organization was null or undefined when calling listRetrieveCustomEventFields.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: Fields;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "Fields");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * 
     * @summary Use this endpoint to get custom events
     * @param apiName api name of the list on which all custom event are requested.
     * @param organization 
     * @param search Optional parameter to search a custom event with a specific name, description or tags.
     * @param skip Optional parameter to specify index to start picking custom event items from.
     * @param take Optional parameter to specify count for the number of custom event items to be taken.
     */
    public async listRetrieveCustomEvents (apiName: string, organization: string, search?: string, skip?: number, take?: number, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: CustomEvents;  }> {
        const localVarPath = this.basePath + '/organizations/{organization}/lists/{api_name}/customevents'
            .replace('{' + 'api_name' + '}', encodeURIComponent(String(apiName)))
            .replace('{' + 'organization' + '}', encodeURIComponent(String(organization)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json', 'text/json', 'custom_events'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'apiName' is not null or undefined
        if (apiName === null || apiName === undefined) {
            throw new Error('Required parameter apiName was null or undefined when calling listRetrieveCustomEvents.');
        }

        // verify required parameter 'organization' is not null or undefined
        if (organization === null || organization === undefined) {
            throw new Error('Required parameter organization was null or undefined when calling listRetrieveCustomEvents.');
        }

        if (search !== undefined) {
            localVarQueryParameters['search'] = ObjectSerializer.serialize(search, "string");
        }

        if (skip !== undefined) {
            localVarQueryParameters['skip'] = ObjectSerializer.serialize(skip, "number");
        }

        if (take !== undefined) {
            localVarQueryParameters['take'] = ObjectSerializer.serialize(take, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: CustomEvents;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "CustomEvents");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * 
     * @summary Use this endpoint to trigger the system, to process all incomming data on the custom event.
     * @param apiName Parameter to specify API name of the list.
     * @param customEventName Parameter to specify custom event name.
     * @param organization 
     */
    public async listTriggerCustomEventResolverJourney (apiName: string, customEventName: string, organization: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: TriggerCustomEventAcceptedResponse;  }> {
        const localVarPath = this.basePath + '/organizations/{organization}/lists/{api_name}/customevents/{custom_event_name}/trigger'
            .replace('{' + 'api_name' + '}', encodeURIComponent(String(apiName)))
            .replace('{' + 'custom_event_name' + '}', encodeURIComponent(String(customEventName)))
            .replace('{' + 'organization' + '}', encodeURIComponent(String(organization)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json', 'text/json', 'result_code', 'message', 'errors', ];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'apiName' is not null or undefined
        if (apiName === null || apiName === undefined) {
            throw new Error('Required parameter apiName was null or undefined when calling listTriggerCustomEventResolverJourney.');
        }

        // verify required parameter 'customEventName' is not null or undefined
        if (customEventName === null || customEventName === undefined) {
            throw new Error('Required parameter customEventName was null or undefined when calling listTriggerCustomEventResolverJourney.');
        }

        // verify required parameter 'organization' is not null or undefined
        if (organization === null || organization === undefined) {
            throw new Error('Required parameter organization was null or undefined when calling listTriggerCustomEventResolverJourney.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: TriggerCustomEventAcceptedResponse;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "TriggerCustomEventAcceptedResponse");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * 
     * @summary Use this endpoint to update a custom event.
     * @param apiName Parameter to specify API name of the list.
     * @param customEventName Parameter to specify custom event name to be updated.
     * @param organization 
     * @param model The model object consists custom event details that are to used to update the custom event
     */
    public async listUpdateCustomEvent (apiName: string, customEventName: string, organization: string, model: UpdateCustomEventRequestModel, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: UpdateCustomEventSuccessExampleResponse;  }> {
        const localVarPath = this.basePath + '/organizations/{organization}/lists/{api_name}/customevents/{custom_event_name}'
            .replace('{' + 'api_name' + '}', encodeURIComponent(String(apiName)))
            .replace('{' + 'custom_event_name' + '}', encodeURIComponent(String(customEventName)))
            .replace('{' + 'organization' + '}', encodeURIComponent(String(organization)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json', 'text/json', 'result_code', 'message', 'errors', ];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'apiName' is not null or undefined
        if (apiName === null || apiName === undefined) {
            throw new Error('Required parameter apiName was null or undefined when calling listUpdateCustomEvent.');
        }

        // verify required parameter 'customEventName' is not null or undefined
        if (customEventName === null || customEventName === undefined) {
            throw new Error('Required parameter customEventName was null or undefined when calling listUpdateCustomEvent.');
        }

        // verify required parameter 'organization' is not null or undefined
        if (organization === null || organization === undefined) {
            throw new Error('Required parameter organization was null or undefined when calling listUpdateCustomEvent.');
        }

        // verify required parameter 'model' is not null or undefined
        if (model === null || model === undefined) {
            throw new Error('Required parameter model was null or undefined when calling listUpdateCustomEvent.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(model, "UpdateCustomEventRequestModel")
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: UpdateCustomEventSuccessExampleResponse;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "UpdateCustomEventSuccessExampleResponse");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * 
     * @summary Use this endpoint to update a custom event field.
     * @param apiName Parameter to specify API name of the list.
     * @param customEventName Parameter to specify custom event name.
     * @param fieldName Parameter to specify custom event field name to be updated
     * @param organization 
     * @param model The model object consists custom event field details that are to used to update a custom event field
     */
    public async listUpdateCustomEventField (apiName: string, customEventName: string, fieldName: string, organization: string, model: UpdateCustomEventFieldRequestModel, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: UpdateCustomEventFieldSuccessResponse;  }> {
        const localVarPath = this.basePath + '/organizations/{organization}/lists/{api_name}/customevents/{custom_event_name}/fields/{field_name}'
            .replace('{' + 'api_name' + '}', encodeURIComponent(String(apiName)))
            .replace('{' + 'custom_event_name' + '}', encodeURIComponent(String(customEventName)))
            .replace('{' + 'field_name' + '}', encodeURIComponent(String(fieldName)))
            .replace('{' + 'organization' + '}', encodeURIComponent(String(organization)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json', 'text/json', 'result_code', 'message', 'errors', ];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'apiName' is not null or undefined
        if (apiName === null || apiName === undefined) {
            throw new Error('Required parameter apiName was null or undefined when calling listUpdateCustomEventField.');
        }

        // verify required parameter 'customEventName' is not null or undefined
        if (customEventName === null || customEventName === undefined) {
            throw new Error('Required parameter customEventName was null or undefined when calling listUpdateCustomEventField.');
        }

        // verify required parameter 'fieldName' is not null or undefined
        if (fieldName === null || fieldName === undefined) {
            throw new Error('Required parameter fieldName was null or undefined when calling listUpdateCustomEventField.');
        }

        // verify required parameter 'organization' is not null or undefined
        if (organization === null || organization === undefined) {
            throw new Error('Required parameter organization was null or undefined when calling listUpdateCustomEventField.');
        }

        // verify required parameter 'model' is not null or undefined
        if (model === null || model === undefined) {
            throw new Error('Required parameter model was null or undefined when calling listUpdateCustomEventField.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(model, "UpdateCustomEventFieldRequestModel")
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: UpdateCustomEventFieldSuccessResponse;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "UpdateCustomEventFieldSuccessResponse");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * 
     * @summary Use this endpoint to update a list.
     * @param apiName Parameter for API name associated with a list.
     * @param organization 
     * @param model The UpdateListRequestModel model parameter contains information about the list such as name, api_name, description, tags, email quaity, taglist_api_name (only for audience list) etc to be updated .
     */
    public async listUpdateList (apiName: string, organization: string, model: UpdateListRequestModel, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: UpdateListSuccessResponse;  }> {
        const localVarPath = this.basePath + '/organizations/{organization}/lists/{api_name}'
            .replace('{' + 'api_name' + '}', encodeURIComponent(String(apiName)))
            .replace('{' + 'organization' + '}', encodeURIComponent(String(organization)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json', 'text/json', 'result_code', 'message', 'errors', ];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'apiName' is not null or undefined
        if (apiName === null || apiName === undefined) {
            throw new Error('Required parameter apiName was null or undefined when calling listUpdateList.');
        }

        // verify required parameter 'organization' is not null or undefined
        if (organization === null || organization === undefined) {
            throw new Error('Required parameter organization was null or undefined when calling listUpdateList.');
        }

        // verify required parameter 'model' is not null or undefined
        if (model === null || model === undefined) {
            throw new Error('Required parameter model was null or undefined when calling listUpdateList.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(model, "UpdateListRequestModel")
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: UpdateListSuccessResponse;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "UpdateListSuccessResponse");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * 
     * @summary Use this endpoint to update an existing field of list.
     * @param apiName Parameter for api_name associated with the list.
     * @param name Parameter for name of the field to be updated.
     * @param organization 
     * @param updateFieldRequestModel Parameter for details containing the new field information.
     */
    public async listUpdateListField (apiName: string, name: string, organization: string, updateFieldRequestModel: UpdateListFieldRequestModel, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: UpdateFieldSuccessResponse;  }> {
        const localVarPath = this.basePath + '/organizations/{organization}/lists/{api_name}/fields/{name}'
            .replace('{' + 'api_name' + '}', encodeURIComponent(String(apiName)))
            .replace('{' + 'name' + '}', encodeURIComponent(String(name)))
            .replace('{' + 'organization' + '}', encodeURIComponent(String(organization)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json', 'text/json', 'result_code', 'message', 'errors', ];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'apiName' is not null or undefined
        if (apiName === null || apiName === undefined) {
            throw new Error('Required parameter apiName was null or undefined when calling listUpdateListField.');
        }

        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling listUpdateListField.');
        }

        // verify required parameter 'organization' is not null or undefined
        if (organization === null || organization === undefined) {
            throw new Error('Required parameter organization was null or undefined when calling listUpdateListField.');
        }

        // verify required parameter 'updateFieldRequestModel' is not null or undefined
        if (updateFieldRequestModel === null || updateFieldRequestModel === undefined) {
            throw new Error('Required parameter updateFieldRequestModel was null or undefined when calling listUpdateListField.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(updateFieldRequestModel, "UpdateListFieldRequestModel")
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: UpdateFieldSuccessResponse;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "UpdateFieldSuccessResponse");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * 
     * @summary Use this endpoint to update an existing relation between the given list and a linked list.
     * @param apiName Parameter to specify API name of list
     * @param scope Parameter to specify name of relation
     * @param organization 
     * @param model Object to specify updates to a relation
     */
    public async listUpdateListRelation (apiName: string, scope: string, organization: string, model: UpdateListRelationRequest, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: UpdateListRelationSuccessResponse;  }> {
        const localVarPath = this.basePath + '/organizations/{organization}/lists/{api_name}/relations/{scope}'
            .replace('{' + 'api_name' + '}', encodeURIComponent(String(apiName)))
            .replace('{' + 'scope' + '}', encodeURIComponent(String(scope)))
            .replace('{' + 'organization' + '}', encodeURIComponent(String(organization)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json', 'text/json', 'result_code', 'message', 'errors', ];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'apiName' is not null or undefined
        if (apiName === null || apiName === undefined) {
            throw new Error('Required parameter apiName was null or undefined when calling listUpdateListRelation.');
        }

        // verify required parameter 'scope' is not null or undefined
        if (scope === null || scope === undefined) {
            throw new Error('Required parameter scope was null or undefined when calling listUpdateListRelation.');
        }

        // verify required parameter 'organization' is not null or undefined
        if (organization === null || organization === undefined) {
            throw new Error('Required parameter organization was null or undefined when calling listUpdateListRelation.');
        }

        // verify required parameter 'model' is not null or undefined
        if (model === null || model === undefined) {
            throw new Error('Required parameter model was null or undefined when calling listUpdateListRelation.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(model, "UpdateListRelationRequest")
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: UpdateListRelationSuccessResponse;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "UpdateListRelationSuccessResponse");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
}

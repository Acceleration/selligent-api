/**
 * Selligent Marketing Cloud API
 * Click the endpoint to see details. In the Parameters-section, we show an example of how the data you send along with the api-call looks like.
 *
 * The version of the OpenAPI document: v1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import localVarRequest = require('request');
import http = require('http');

/* tslint:disable:no-unused-locals */
import { ClearStaticSegmentDataFailedResponse } from '../model/clearStaticSegmentDataFailedResponse';
import { ClearStaticSegmentDataSuccessResponse } from '../model/clearStaticSegmentDataSuccessResponse';
import { DeleteDataResponseModel } from '../model/deleteDataResponseModel';
import { LoadDataResponseModel } from '../model/loadDataResponseModel';
import { RetrieveEngagementListRecordExampleResponseModel } from '../model/retrieveEngagementListRecordExampleResponseModel';
import { RetrieveInterestListRecordExampleResponseModel } from '../model/retrieveInterestListRecordExampleResponseModel';
import { SaveListDataResponsed } from '../model/saveListDataResponsed';
import { SearchDataRequestModel } from '../model/searchDataRequestModel';
import { SearchDataResponseModel } from '../model/searchDataResponseModel';

import { ObjectSerializer, Authentication, VoidAuth, Interceptor } from '../model/models';

import { HttpError, RequestFile } from './apis';

let defaultBasePath = 'http://localhost/Portal/Api';

// ===============================================
// This file is autogenerated - Please do not edit
// ===============================================

export enum DataApiApiKeys {
}

export class DataApi {
    protected _basePath = defaultBasePath;
    protected _defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    protected interceptors: Interceptor[] = [];

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    set defaultHeaders(defaultHeaders: any) {
        this._defaultHeaders = defaultHeaders;
    }

    get defaultHeaders() {
        return this._defaultHeaders;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
        this.authentications.default = auth;
    }

    public setApiKey(key: DataApiApiKeys, value: string) {
        (this.authentications as any)[DataApiApiKeys[key]].apiKey = value;
    }

    public addInterceptor(interceptor: Interceptor) {
        this.interceptors.push(interceptor);
    }

    /**
     * 
     * @summary Use this endpoint to clear static segment data
     * @param apiName Parameter for API name associated with a list
     * @param segmentApiName Parameter for API name associated with a segment
     * @param organization 
     */
    public async dataClearStaticSegmentData (apiName: string, segmentApiName: string, organization: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: ClearStaticSegmentDataSuccessResponse;  }> {
        const localVarPath = this.basePath + '/organizations/{organization}/lists/{api_name}/segments/{segment_api_name}/data/clear'
            .replace('{' + 'api_name' + '}', encodeURIComponent(String(apiName)))
            .replace('{' + 'segment_api_name' + '}', encodeURIComponent(String(segmentApiName)))
            .replace('{' + 'organization' + '}', encodeURIComponent(String(organization)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json', 'text/json', 'result_code', 'message', 'errors', ];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'apiName' is not null or undefined
        if (apiName === null || apiName === undefined) {
            throw new Error('Required parameter apiName was null or undefined when calling dataClearStaticSegmentData.');
        }

        // verify required parameter 'segmentApiName' is not null or undefined
        if (segmentApiName === null || segmentApiName === undefined) {
            throw new Error('Required parameter segmentApiName was null or undefined when calling dataClearStaticSegmentData.');
        }

        // verify required parameter 'organization' is not null or undefined
        if (organization === null || organization === undefined) {
            throw new Error('Required parameter organization was null or undefined when calling dataClearStaticSegmentData.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: ClearStaticSegmentDataSuccessResponse;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "ClearStaticSegmentDataSuccessResponse");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * 
     * @summary Use this endpoint to delete data from a specific table.
     * @param apiName Parameter represents API name of the list.
     * @param keyFields Parameter contains a comma-separated list of the key fields that need to be used to delete records.
     * @param organization 
     * @param jsondata 
     * @param fields Parameter indicates a comma-separated list of the fields that are in the provided data records.
     * @param mode Parameter indicates the mode of the data transfer (Sync or Stream). [Default: Sync]
     * @param errorHandling Parameter indicates error handling options whether to stop on error or continue on error
     */
    public async dataDeleteData (apiName: string, keyFields: string, organization: string, jsondata: Array<Array<string>>, fields?: string, mode?: string, errorHandling?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: DeleteDataResponseModel;  }> {
        const localVarPath = this.basePath + '/organizations/{organization}/lists/{api_name}/data'
            .replace('{' + 'api_name' + '}', encodeURIComponent(String(apiName)))
            .replace('{' + 'organization' + '}', encodeURIComponent(String(organization)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json', 'text/json', 'result_code', 'number_of_deleted_records', 'number_of_duplicate_records', 'number_of_failed_records', 'number_of_records_not_found', 'invalid_records'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'apiName' is not null or undefined
        if (apiName === null || apiName === undefined) {
            throw new Error('Required parameter apiName was null or undefined when calling dataDeleteData.');
        }

        // verify required parameter 'keyFields' is not null or undefined
        if (keyFields === null || keyFields === undefined) {
            throw new Error('Required parameter keyFields was null or undefined when calling dataDeleteData.');
        }

        // verify required parameter 'organization' is not null or undefined
        if (organization === null || organization === undefined) {
            throw new Error('Required parameter organization was null or undefined when calling dataDeleteData.');
        }

        // verify required parameter 'jsondata' is not null or undefined
        if (jsondata === null || jsondata === undefined) {
            throw new Error('Required parameter jsondata was null or undefined when calling dataDeleteData.');
        }

        if (keyFields !== undefined) {
            localVarQueryParameters['keyFields'] = ObjectSerializer.serialize(keyFields, "string");
        }

        if (fields !== undefined) {
            localVarQueryParameters['fields'] = ObjectSerializer.serialize(fields, "string");
        }

        if (mode !== undefined) {
            localVarQueryParameters['mode'] = ObjectSerializer.serialize(mode, "string");
        }

        if (errorHandling !== undefined) {
            localVarQueryParameters['errorHandling'] = ObjectSerializer.serialize(errorHandling, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(jsondata, "Array<Array<string>>")
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: DeleteDataResponseModel;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "DeleteDataResponseModel");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * 
     * @summary Use this endpoint to delete data from a specific static segment.
     * @param apiName Parameter represents API name of the list.
     * @param segmentApiName Parameter represents API name of the segment.
     * @param keyFields Parameter contains a comma-separated list of the key fields that need to be used to delete records.
     * @param organization 
     * @param jsondata 
     * @param fields Parameter indicates a comma-separated list of the fields that are in the provided data records.
     * @param mode Parameter indicates the mode of the data transfer (Sync or Stream). [Default: Sync]
     * @param errorHandling Parameter indicates error handling options whether to stop on error or continue on error
     */
    public async dataDeleteSegmentData (apiName: string, segmentApiName: string, keyFields: string, organization: string, jsondata: Array<Array<string>>, fields?: string, mode?: string, errorHandling?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: DeleteDataResponseModel;  }> {
        const localVarPath = this.basePath + '/organizations/{organization}/lists/{api_name}/segments/{segment_api_name}/data'
            .replace('{' + 'api_name' + '}', encodeURIComponent(String(apiName)))
            .replace('{' + 'segment_api_name' + '}', encodeURIComponent(String(segmentApiName)))
            .replace('{' + 'organization' + '}', encodeURIComponent(String(organization)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json', 'text/json', 'result_code', 'number_of_deleted_records', 'number_of_duplicate_records', 'number_of_failed_records', 'number_of_records_not_found', 'invalid_records'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'apiName' is not null or undefined
        if (apiName === null || apiName === undefined) {
            throw new Error('Required parameter apiName was null or undefined when calling dataDeleteSegmentData.');
        }

        // verify required parameter 'segmentApiName' is not null or undefined
        if (segmentApiName === null || segmentApiName === undefined) {
            throw new Error('Required parameter segmentApiName was null or undefined when calling dataDeleteSegmentData.');
        }

        // verify required parameter 'keyFields' is not null or undefined
        if (keyFields === null || keyFields === undefined) {
            throw new Error('Required parameter keyFields was null or undefined when calling dataDeleteSegmentData.');
        }

        // verify required parameter 'organization' is not null or undefined
        if (organization === null || organization === undefined) {
            throw new Error('Required parameter organization was null or undefined when calling dataDeleteSegmentData.');
        }

        // verify required parameter 'jsondata' is not null or undefined
        if (jsondata === null || jsondata === undefined) {
            throw new Error('Required parameter jsondata was null or undefined when calling dataDeleteSegmentData.');
        }

        if (keyFields !== undefined) {
            localVarQueryParameters['keyFields'] = ObjectSerializer.serialize(keyFields, "string");
        }

        if (fields !== undefined) {
            localVarQueryParameters['fields'] = ObjectSerializer.serialize(fields, "string");
        }

        if (mode !== undefined) {
            localVarQueryParameters['mode'] = ObjectSerializer.serialize(mode, "string");
        }

        if (errorHandling !== undefined) {
            localVarQueryParameters['errorHandling'] = ObjectSerializer.serialize(errorHandling, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(jsondata, "Array<Array<string>>")
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: DeleteDataResponseModel;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "DeleteDataResponseModel");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * 
     * @summary Use this endpoint to retrieve engagement list record data for specified channel type and master list record.
     * @param apiName Parameter for API name associated with a list.
     * @param channel Parameter for channel associated with a list.
     * @param recordId Parameter for record id associated with a list.
     * @param organization 
     */
    public async dataGetEngagementListRecord (apiName: string, channel: 'Email' | 'Sms' | 'Mobile' | 'Web', recordId: number, organization: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: RetrieveEngagementListRecordExampleResponseModel;  }> {
        const localVarPath = this.basePath + '/organizations/{organization}/lists/{api_name}/engagement/{channel}/data/{record_id}'
            .replace('{' + 'api_name' + '}', encodeURIComponent(String(apiName)))
            .replace('{' + 'channel' + '}', encodeURIComponent(String(channel)))
            .replace('{' + 'record_id' + '}', encodeURIComponent(String(recordId)))
            .replace('{' + 'organization' + '}', encodeURIComponent(String(organization)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json', 'text/json', 'record'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'apiName' is not null or undefined
        if (apiName === null || apiName === undefined) {
            throw new Error('Required parameter apiName was null or undefined when calling dataGetEngagementListRecord.');
        }

        // verify required parameter 'channel' is not null or undefined
        if (channel === null || channel === undefined) {
            throw new Error('Required parameter channel was null or undefined when calling dataGetEngagementListRecord.');
        }

        // verify required parameter 'recordId' is not null or undefined
        if (recordId === null || recordId === undefined) {
            throw new Error('Required parameter recordId was null or undefined when calling dataGetEngagementListRecord.');
        }

        // verify required parameter 'organization' is not null or undefined
        if (organization === null || organization === undefined) {
            throw new Error('Required parameter organization was null or undefined when calling dataGetEngagementListRecord.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: RetrieveEngagementListRecordExampleResponseModel;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "RetrieveEngagementListRecordExampleResponseModel");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * 
     * @summary Use this endpoint to retrieve interest list record data for specified channel type and master list record.
     * @param apiName Parameter for API name associated with a list.
     * @param channel Parameter for channel associated with a list.
     * @param recordId Parameter for record id associated with a list.
     * @param organization 
     */
    public async dataGetInterestListRecord (apiName: string, channel: 'Email' | 'Sms' | 'Mobile' | 'Web', recordId: number, organization: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: RetrieveInterestListRecordExampleResponseModel;  }> {
        const localVarPath = this.basePath + '/organizations/{organization}/lists/{api_name}/interest/{channel}/data/{record_id}'
            .replace('{' + 'api_name' + '}', encodeURIComponent(String(apiName)))
            .replace('{' + 'channel' + '}', encodeURIComponent(String(channel)))
            .replace('{' + 'record_id' + '}', encodeURIComponent(String(recordId)))
            .replace('{' + 'organization' + '}', encodeURIComponent(String(organization)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json', 'text/json', 'record'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'apiName' is not null or undefined
        if (apiName === null || apiName === undefined) {
            throw new Error('Required parameter apiName was null or undefined when calling dataGetInterestListRecord.');
        }

        // verify required parameter 'channel' is not null or undefined
        if (channel === null || channel === undefined) {
            throw new Error('Required parameter channel was null or undefined when calling dataGetInterestListRecord.');
        }

        // verify required parameter 'recordId' is not null or undefined
        if (recordId === null || recordId === undefined) {
            throw new Error('Required parameter recordId was null or undefined when calling dataGetInterestListRecord.');
        }

        // verify required parameter 'organization' is not null or undefined
        if (organization === null || organization === undefined) {
            throw new Error('Required parameter organization was null or undefined when calling dataGetInterestListRecord.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: RetrieveInterestListRecordExampleResponseModel;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "RetrieveInterestListRecordExampleResponseModel");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * 
     * @summary Use this endpoint to load data into a specific table.
     * @param apiName Parameter represents API name of the list.
     * @param keyFields Parameter contains a comma-separated list of the key fields that need to be used to create or update records.
     * @param organization 
     * @param jsondata 
     * @param fields Optional parameter containing a comma-separated list of the fields that are in the provided data records. Make sure that this list contains ALL fields (including the key fields) in the correct order. If this parameter is not provided, the first row of the provided data records will be used to determine the fields.
     * @param mode Parameter indicates the mode of the data transfer (Sync or Stream). [Default: Sync]
     * @param deduplication Parameter indicates the de-duplication option during an import data (ImportLastMatch or ImportFirstMatch). [Default: ImportLastMatch]
     * @param dataImportOption Parameter indicates the data import option during an import data (InsertAndUpdate or OnlyInsert or OnlyUpdate). [Default: InsertAndUpdate]
     * @param createSegmentName Parameter indicates the name of segment at the time of segment creation
     * @param createSegmentApiName Parameter indicates the api name of segment at the time of segment creation
     * @param errorHandling Parameter indicates error handling options whether to stop on error or continue on error
     */
    public async dataLoadData (apiName: string, keyFields: string, organization: string, jsondata: Array<Array<string>>, fields?: string, mode?: string, deduplication?: string, dataImportOption?: string, createSegmentName?: string, createSegmentApiName?: string, errorHandling?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: LoadDataResponseModel;  }> {
        const localVarPath = this.basePath + '/organizations/{organization}/lists/{api_name}/data/load'
            .replace('{' + 'api_name' + '}', encodeURIComponent(String(apiName)))
            .replace('{' + 'organization' + '}', encodeURIComponent(String(organization)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json', 'text/json', 'result_code', 'number_of_inserted_records', 'number_of_failed_records', 'number_of_updated_records', 'number_of_duplicate_records', 'number_of_records_not_found', 'invalid_records', 'number_of_deleted_records'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'apiName' is not null or undefined
        if (apiName === null || apiName === undefined) {
            throw new Error('Required parameter apiName was null or undefined when calling dataLoadData.');
        }

        // verify required parameter 'keyFields' is not null or undefined
        if (keyFields === null || keyFields === undefined) {
            throw new Error('Required parameter keyFields was null or undefined when calling dataLoadData.');
        }

        // verify required parameter 'organization' is not null or undefined
        if (organization === null || organization === undefined) {
            throw new Error('Required parameter organization was null or undefined when calling dataLoadData.');
        }

        // verify required parameter 'jsondata' is not null or undefined
        if (jsondata === null || jsondata === undefined) {
            throw new Error('Required parameter jsondata was null or undefined when calling dataLoadData.');
        }

        if (keyFields !== undefined) {
            localVarQueryParameters['keyFields'] = ObjectSerializer.serialize(keyFields, "string");
        }

        if (fields !== undefined) {
            localVarQueryParameters['fields'] = ObjectSerializer.serialize(fields, "string");
        }

        if (mode !== undefined) {
            localVarQueryParameters['mode'] = ObjectSerializer.serialize(mode, "string");
        }

        if (deduplication !== undefined) {
            localVarQueryParameters['deduplication'] = ObjectSerializer.serialize(deduplication, "string");
        }

        if (dataImportOption !== undefined) {
            localVarQueryParameters['data_import_option'] = ObjectSerializer.serialize(dataImportOption, "string");
        }

        if (createSegmentName !== undefined) {
            localVarQueryParameters['create_segment_name'] = ObjectSerializer.serialize(createSegmentName, "string");
        }

        if (createSegmentApiName !== undefined) {
            localVarQueryParameters['create_segment_api_name'] = ObjectSerializer.serialize(createSegmentApiName, "string");
        }

        if (errorHandling !== undefined) {
            localVarQueryParameters['errorHandling'] = ObjectSerializer.serialize(errorHandling, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(jsondata, "Array<Array<string>>")
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: LoadDataResponseModel;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "LoadDataResponseModel");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * 
     * @summary Use this endpoint to load data into a specific static segment.
     * @param apiName Parameter represents API name of the list.
     * @param segmentApiName Parameter represents API name of the segment.
     * @param keyFields Parameter contains a comma-separated list of the key fields that need to be used to create or update records.
     * @param organization 
     * @param jsondata 
     * @param fields Optional parameter containing a comma-separated list of the fields that are in the provided data records. Make sure that this list contains ALL fields (including the key fields) in the correct order. If this parameter is not provided, the first row of the provided data records will be used to determine the fields.
     * @param mode Parameter indicates the mode of the data transfer (Sync or Stream). [Default: Sync]
     * @param deduplication Parameter indicates the de-duplication option during an import data (ImportLastMatch or ImportFirstMatch). [Default: ImportLastMatch]
     * @param errorHandling Parameter indicates error handling options whether to stop on error or continue on error
     */
    public async dataLoadSegmentData (apiName: string, segmentApiName: string, keyFields: string, organization: string, jsondata: Array<Array<string>>, fields?: string, mode?: string, deduplication?: string, errorHandling?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: LoadDataResponseModel;  }> {
        const localVarPath = this.basePath + '/organizations/{organization}/lists/{api_name}/segments/{segment_api_name}/data/load'
            .replace('{' + 'api_name' + '}', encodeURIComponent(String(apiName)))
            .replace('{' + 'segment_api_name' + '}', encodeURIComponent(String(segmentApiName)))
            .replace('{' + 'organization' + '}', encodeURIComponent(String(organization)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json', 'text/json', 'result_code', 'number_of_inserted_records', 'number_of_failed_records', 'number_of_updated_records', 'number_of_duplicate_records', 'number_of_records_not_found', 'invalid_records', 'number_of_deleted_records'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'apiName' is not null or undefined
        if (apiName === null || apiName === undefined) {
            throw new Error('Required parameter apiName was null or undefined when calling dataLoadSegmentData.');
        }

        // verify required parameter 'segmentApiName' is not null or undefined
        if (segmentApiName === null || segmentApiName === undefined) {
            throw new Error('Required parameter segmentApiName was null or undefined when calling dataLoadSegmentData.');
        }

        // verify required parameter 'keyFields' is not null or undefined
        if (keyFields === null || keyFields === undefined) {
            throw new Error('Required parameter keyFields was null or undefined when calling dataLoadSegmentData.');
        }

        // verify required parameter 'organization' is not null or undefined
        if (organization === null || organization === undefined) {
            throw new Error('Required parameter organization was null or undefined when calling dataLoadSegmentData.');
        }

        // verify required parameter 'jsondata' is not null or undefined
        if (jsondata === null || jsondata === undefined) {
            throw new Error('Required parameter jsondata was null or undefined when calling dataLoadSegmentData.');
        }

        if (keyFields !== undefined) {
            localVarQueryParameters['keyFields'] = ObjectSerializer.serialize(keyFields, "string");
        }

        if (fields !== undefined) {
            localVarQueryParameters['fields'] = ObjectSerializer.serialize(fields, "string");
        }

        if (mode !== undefined) {
            localVarQueryParameters['mode'] = ObjectSerializer.serialize(mode, "string");
        }

        if (deduplication !== undefined) {
            localVarQueryParameters['deduplication'] = ObjectSerializer.serialize(deduplication, "string");
        }

        if (errorHandling !== undefined) {
            localVarQueryParameters['errorHandling'] = ObjectSerializer.serialize(errorHandling, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(jsondata, "Array<Array<string>>")
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: LoadDataResponseModel;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "LoadDataResponseModel");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * 
     * @summary Use this endpoint to create or update a single record with data on a 1:1 relation
     * @param apiName Parameter represents API name of the list.
     * @param keyfields Parameter contains a comma-separated list of the key fields that need to be used to create or update records.
     * @param organization 
     * @param values Parameter contains a key value pair dictionary of the master record data or slave record data.
     */
    public async dataSaveListData (apiName: string, keyfields: string, organization: string, values: { [key: string]: object; }, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: SaveListDataResponsed;  }> {
        const localVarPath = this.basePath + '/organizations/{organization}/lists/{api_name}/data'
            .replace('{' + 'api_name' + '}', encodeURIComponent(String(apiName)))
            .replace('{' + 'organization' + '}', encodeURIComponent(String(organization)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json', 'text/json', 'result_code', 'message'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'apiName' is not null or undefined
        if (apiName === null || apiName === undefined) {
            throw new Error('Required parameter apiName was null or undefined when calling dataSaveListData.');
        }

        // verify required parameter 'keyfields' is not null or undefined
        if (keyfields === null || keyfields === undefined) {
            throw new Error('Required parameter keyfields was null or undefined when calling dataSaveListData.');
        }

        // verify required parameter 'organization' is not null or undefined
        if (organization === null || organization === undefined) {
            throw new Error('Required parameter organization was null or undefined when calling dataSaveListData.');
        }

        // verify required parameter 'values' is not null or undefined
        if (values === null || values === undefined) {
            throw new Error('Required parameter values was null or undefined when calling dataSaveListData.');
        }

        if (keyfields !== undefined) {
            localVarQueryParameters['keyfields'] = ObjectSerializer.serialize(keyfields, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(values, "{ [key: string]: object; }")
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: SaveListDataResponsed;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "SaveListDataResponsed");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * 
     * @summary Use this endpoint to search for data records in a specific table.  Searching data can be done synchronous or streamed.  The data in the response will be in a Json format.
     * @param apiName Parameter represents the API name of the list.
     * @param organization 
     * @param request Parameter specifies the details on the data that should be searched.
     * @param mode Parameter indicates the mode of the data transfer (Sync or Stream). [Default: Sync]
     */
    public async dataSearchData (apiName: string, organization: string, request: SearchDataRequestModel, mode?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: SearchDataResponseModel;  }> {
        const localVarPath = this.basePath + '/organizations/{organization}/lists/{api_name}/data/search'
            .replace('{' + 'api_name' + '}', encodeURIComponent(String(apiName)))
            .replace('{' + 'organization' + '}', encodeURIComponent(String(organization)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json', 'text/json', 'fields', 'data', 'result_code', 'errors'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'apiName' is not null or undefined
        if (apiName === null || apiName === undefined) {
            throw new Error('Required parameter apiName was null or undefined when calling dataSearchData.');
        }

        // verify required parameter 'organization' is not null or undefined
        if (organization === null || organization === undefined) {
            throw new Error('Required parameter organization was null or undefined when calling dataSearchData.');
        }

        // verify required parameter 'request' is not null or undefined
        if (request === null || request === undefined) {
            throw new Error('Required parameter request was null or undefined when calling dataSearchData.');
        }

        if (mode !== undefined) {
            localVarQueryParameters['mode'] = ObjectSerializer.serialize(mode, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(request, "SearchDataRequestModel")
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: SearchDataResponseModel;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "SearchDataResponseModel");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * 
     * @summary Use this endpoint to search for data records within a segment of a specific table.  Searching data can be done synchronous or streamed.  The data in the response will be in a Json format.
     * @param apiName Parameter represents the API name of the list.
     * @param segmentApiName Parameter represents the API name of the segment.
     * @param organization 
     * @param request Parameter specifies the details on the data that should be searched.
     * @param mode Parameter indicates the mode of the data transfer (Sync or Stream). [Default: Sync]
     */
    public async dataSearchSegmentData (apiName: string, segmentApiName: string, organization: string, request: SearchDataRequestModel, mode?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: object;  }> {
        const localVarPath = this.basePath + '/organizations/{organization}/lists/{api_name}/segments/{segment_api_name}/data/search'
            .replace('{' + 'api_name' + '}', encodeURIComponent(String(apiName)))
            .replace('{' + 'segment_api_name' + '}', encodeURIComponent(String(segmentApiName)))
            .replace('{' + 'organization' + '}', encodeURIComponent(String(organization)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json', 'text/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'apiName' is not null or undefined
        if (apiName === null || apiName === undefined) {
            throw new Error('Required parameter apiName was null or undefined when calling dataSearchSegmentData.');
        }

        // verify required parameter 'segmentApiName' is not null or undefined
        if (segmentApiName === null || segmentApiName === undefined) {
            throw new Error('Required parameter segmentApiName was null or undefined when calling dataSearchSegmentData.');
        }

        // verify required parameter 'organization' is not null or undefined
        if (organization === null || organization === undefined) {
            throw new Error('Required parameter organization was null or undefined when calling dataSearchSegmentData.');
        }

        // verify required parameter 'request' is not null or undefined
        if (request === null || request === undefined) {
            throw new Error('Required parameter request was null or undefined when calling dataSearchSegmentData.');
        }

        if (mode !== undefined) {
            localVarQueryParameters['mode'] = ObjectSerializer.serialize(mode, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(request, "SearchDataRequestModel")
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: object;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "object");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
}
